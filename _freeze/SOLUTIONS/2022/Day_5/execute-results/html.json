{
  "hash": "6df92f69ee6c3a243fb3324f84831cfb",
  "result": {
    "markdown": "---\ntitle: \"Day 5\"\nauthor: \"Julia Romanowska\"\n---\n\n\n\n\n## Data\n\nThe input is one file, but two parts:\n\n- first, the order of crates in stacks\n- next, the movement procedure\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput_file_path <- here(\"DATA\", \"2022\", \"input_day_05.txt\")\n\ncat(system(paste(\"head\", input_file_path), intern = TRUE), sep = \"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[N]     [Q]         [N]            \n[R]     [F] [Q]     [G] [M]        \n[J]     [Z] [T]     [R] [H] [J]    \n[T] [H] [G] [R]     [B] [N] [T]    \n[Z] [J] [J] [G] [F] [Z] [S] [M]    \n[B] [N] [N] [N] [Q] [W] [L] [Q] [S]\n[D] [S] [R] [V] [T] [C] [C] [N] [G]\n[F] [R] [C] [F] [L] [Q] [F] [D] [P]\n 1   2   3   4   5   6   7   8   9 \n```\n:::\n:::\n\n\n::: {.card .border-success .mb-3}\n::: {.card-text}\nI should probably create a nice code where I read in the input and convert it\nto the list of vectors, but I don't have time now ðŸ˜Ž\n:::\n:::\n\nI have splitted the input file to get separate input for the stacks and for the\ninstructions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem(\"./Day_5_split_input.sh\")\nlist.files(here(\"DATA\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022\" \"2023\"\n```\n:::\n\n```{.r .cell-code}\n(instructions <- read_table(\n  here(\"DATA\", \"2022\", \"input_day_05_instructions.txt\"),\n  show_col_types = FALSE,\n  col_names = FALSE\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 503 Ã— 6\n   X1       X2 X3       X4 X5       X6\n   <chr> <dbl> <chr> <dbl> <chr> <dbl>\n 1 move      3 from      9 to        4\n 2 move      2 from      5 to        2\n 3 move      8 from      1 to        9\n 4 move      4 from      7 to        1\n 5 move      5 from      3 to        8\n 6 move      3 from      3 to        7\n 7 move     11 from      8 to        3\n 8 move      7 from      3 to        6\n 9 move      2 from      5 to        9\n10 move      3 from      1 to        6\n# â„¹ 493 more rows\n```\n:::\n\n```{.r .cell-code}\ninstructions <- instructions %>%\n  select(move_how_many = X2, from = X4, to = X6)\n```\n:::\n\n\nNow, creating a list of vectors for the initial stack of crates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninit_stacks <- list(\n  stack1 = c(\"F\", \"D\", \"B\", \"Z\", \"T\", \"J\", \"R\", \"N\"),\n  stack2 = c(\"R\", \"S\", \"N\", \"J\", \"H\"),\n  stack3 = c(\"C\", \"R\", \"N\", \"J\", \"G\", \"Z\", \"F\", \"Q\"),\n  stack4 = c(\"F\", \"V\", \"N\", \"G\", \"R\", \"T\", \"Q\"),\n  stack5 = c(\"L\", \"T\", \"Q\", \"F\"),\n  stack6 = c(\"Q\", \"C\", \"W\", \"Z\", \"B\", \"R\", \"G\", \"N\"),\n  stack7 = c(\"F\", \"C\", \"L\", \"S\", \"N\", \"H\", \"M\"),\n  stack8 = c(\"D\", \"N\", \"Q\", \"M\", \"T\", \"J\"),\n  stack9 = c(\"P\", \"G\", \"S\")\n)\n```\n:::\n\n\n## Functions\n\nThis looks like we need some type queue function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npush_back <- function(stacks, from, to){\n  stack_name_from <- paste0(\"stack\", from)\n  stack_name_to <- paste0(\"stack\", to)\n  \n  length_from <- length(stacks[[stack_name_from]])\n  \n  crate_to_move <- stacks[[stack_name_from]][length_from]\n  new_stacks <- stacks\n  new_stacks[[stack_name_from]] <- stacks[[stack_name_from]][-length_from]\n  new_stacks[[stack_name_to]] <- c(stacks[[stack_name_to]], crate_to_move)\n  \n  return(new_stacks)\n}\n```\n:::\n\n\n## Rearranging\n\nThis is best in base R...\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncur_stacks <- init_stacks\n\nfor(i in nrow(instructions)){\n  cur_instruction <- instructions[i,]\n\n  for(j in 1:(cur_instruction$move_how_many)){\n    cur_stacks <<- push_back(cur_stacks, cur_instruction$from, cur_instruction$to)\n  }\n}\ncur_stacks\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$stack1\n[1] \"F\" \"D\" \"B\" \"Z\" \"T\" \"J\" \"R\" \"N\"\n\n$stack2\n[1] \"R\" \"S\" \"N\" \"J\" \"H\"\n\n$stack3\n[1] \"C\" \"R\" \"N\" \"J\" \"G\" \"Z\" \"F\" \"Q\"\n\n$stack4\n[1] \"F\" \"V\" \"N\" \"G\" \"R\" \"T\" \"Q\"\n\n$stack5\n[1] \"L\" \"T\" \"Q\" \"F\"\n\n$stack6\n[1] \"Q\" \"C\" \"W\" \"Z\" \"B\"\n\n$stack7\n[1] \"F\" \"C\" \"L\" \"S\" \"N\" \"H\" \"M\"\n\n$stack8\n[1] \"D\" \"N\" \"Q\" \"M\" \"T\" \"J\"\n\n$stack9\n[1] \"P\" \"G\" \"S\" \"N\" \"G\" \"R\"\n```\n:::\n:::\n\n\n## What's on top?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntop_crates <- map_chr(\n  cur_stacks,\n  function(stack){\n    l_stack <- length(stack)\n    return(stack[l_stack])\n  }\n)\n```\n:::\n\n\n::: {.card .border-success .mb-3}\n::: {.card-text}\nThe last crates on all stacks: NHQQFBMJR! Wrong? ðŸ¤”\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}