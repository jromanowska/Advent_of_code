{
  "hash": "5bac7c8af659f8e6cf3fc2a0091d0fa0",
  "result": {
    "markdown": "---\ntitle: Day 3\nauthor: Julia Romanowska\n---\n\n\n## The input\n\nEach line consists of symbols and digits. Digits form numbers, delimited by\neither `.` (full stop) or another symbol. A number is part of the engine if\nit is adjacent to any symbol other than `.` (even diagonally).\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n#input_file = open(\"../../DATA/2023/input_day03.txt\", \"r\");\ninput_file = open(\"../../DATA/2023/example_input_day03.txt\", \"r\");\nprintln(peek(input_file, String))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n\n```\n:::\n:::\n\n\n## Part 1\n\nWhat I need to do is:\n\n1. find all the numbers and their positions (line number and column number)\n2. find all the symbols that are not `.` and their positions\n3. check positions of numbers against positions of symbols (a la rolling join)\n\n### Find all the numbers and symbols, and their positions\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nall_numbers_positions = DataFrame(\n    cur_number = 0,\n    line_no = 0,\n    column_start = 0,\n    column_end = 0\n);\n\nall_symbols_positions = DataFrame(\n    cur_symbol = 0,\n    line_no = 0,\n    column_pos = 0\n);\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nfunction match_all(pattern::Regex, where_to_match::String)\n    all_positions = Int32[];\n    all_matches = String[];\n    idx = 1;\n    while idx < lastindex(where_to_match)\n        m = match(pattern, where_to_match, idx);\n        if isnothing(m)\n            break\n        end\n        push!(all_positions, m.offset);\n        push!(all_matches, m.match);\n        idx = m.offset + 1;\n    end\n    return DataFrame(\n        cur_number = all_matches,\n        cur_position = all_positions\n    )\nend\n```\n\n::: {#match_function .cell-output .cell-output-display execution_count=5}\n```\nmatch_all (generic function with 1 method)\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nline = readline(input_file);\ncur_line_no = 1;\nwhile line != \"\"\n    # find digits...\n    cur_line_numbers_found = match_all(r\"\\d\", line);\n    # and make them into numbers\n    #   find difference in position from the previous digit:\n    diff_numbers_positions = [2; diff(cur_line_numbers_found.cur_position)];\n    # the next will be simpler if I create groups based on the position\n    cur_group = 0;\n    groups = Int32[];\n    for idx in diff_numbers_positions\n        if idx != 1\n            global cur_group += 1;\n        end\n        push!(groups, cur_group);\n    end\n    cur_line_numbers_found[:, :group_no] = groups;\n    #   find beginning and end of each number:\n    cur_numbers_out = combine(\n        groupby(cur_line_numbers_found, :group_no),\n        [:cur_number, :cur_position] =>\n         ((n, p) -> (cur_number = parse(Int32, string(n...)),\n                    column_start = min(p...),\n                    column_end = max(p...))) =>\n         AsTable\n    );\n    cur_numbers_out[:, :line_no] = fill(cur_line_no, nrow(cur_numbers_out));\n    select!(cur_numbers_out, Not(:group_no));\n    #  finally, add to the big table\n    append!(all_numbers_positions, cur_numbers_out);\n\n    # find symbols...\n    cur_line_symbols_found = match_all(r\"[^\\d.]\", line);\n    # and place in the DataFrame\n    append!(\n        all_symbols_positions,\n        DataFrame(\n            cur_symbol = cur_line_symbols_found.cur_number,\n            line_no = fill(cur_line_no, nrow(cur_line_symbols_found)),\n            column_pos = cur_line_symbols_found.cur_position\n        )\n    )\n\n    # read the next line:\n    global line = readline(input_file);\n    global cur_line_no =+ 1;\nend\n\nclose(input_file)\n```\n\n::: {.cell-output .cell-output-error}\n```\nLoadError: syntax: `global cur_group`: cur_group is a local variable in its enclosing scope\n```\n:::\n:::\n\n\n",
    "supporting": [
      "Day_03_files"
    ],
    "filters": [],
    "includes": {}
  }
}