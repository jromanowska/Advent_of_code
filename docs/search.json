[
  {
    "objectID": "SOLUTIONS/Day_5.html",
    "href": "SOLUTIONS/Day_5.html",
    "title": "Day 5",
    "section": "",
    "text": "The input is one file, but two parts:\n\nfirst, the order of crates in stacks\nnext, the movement procedure\n\n\ninput_file_path <- here(\"DATA\", \"input_day_05.txt\")\n\ncat(system(paste(\"head\", input_file_path), intern = TRUE), sep = \"\\n\")\n\n[N]     [Q]         [N]            \n[R]     [F] [Q]     [G] [M]        \n[J]     [Z] [T]     [R] [H] [J]    \n[T] [H] [G] [R]     [B] [N] [T]    \n[Z] [J] [J] [G] [F] [Z] [S] [M]    \n[B] [N] [N] [N] [Q] [W] [L] [Q] [S]\n[D] [S] [R] [V] [T] [C] [C] [N] [G]\n[F] [R] [C] [F] [L] [Q] [F] [D] [P]\n 1   2   3   4   5   6   7   8   9 \n\n\n\n\nI should probably create a nice code where I read in the input and convert it to the list of vectors, but I don‚Äôt have time now üòé\n\n\nI have splitted the input file to get separate input for the stacks and for the instructions.\n\nsystem(\"./Day_5_split_input.sh\")\nlist.files(here(\"DATA\"))\n\n[1] \"input_day_01.txt\"              \"input_day_02.txt\"             \n[3] \"input_day_03.txt\"              \"input_day_04.txt\"             \n[5] \"input_day_05_instructions.txt\" \"input_day_05_stacks.txt\"      \n[7] \"input_day_05.txt\"              \"input_day_06.txt\"             \n\n(instructions <- read_table(\n  here(\"DATA\", \"input_day_05_instructions.txt\"),\n  show_col_types = FALSE,\n  col_names = FALSE\n))\n\n# A tibble: 503 √ó 6\n   X1       X2 X3       X4 X5       X6\n   <chr> <dbl> <chr> <dbl> <chr> <dbl>\n 1 move      3 from      9 to        4\n 2 move      2 from      5 to        2\n 3 move      8 from      1 to        9\n 4 move      4 from      7 to        1\n 5 move      5 from      3 to        8\n 6 move      3 from      3 to        7\n 7 move     11 from      8 to        3\n 8 move      7 from      3 to        6\n 9 move      2 from      5 to        9\n10 move      3 from      1 to        6\n# ‚Ä¶ with 493 more rows\n\ninstructions <- instructions %>%\n  select(move_how_many = X2, from = X4, to = X6)\n\nNow, creating a list of vectors for the initial stack of crates.\n\ninit_stacks <- list(\n  stack1 = c(\"F\", \"D\", \"B\", \"Z\", \"T\", \"J\", \"R\", \"N\"),\n  stack2 = c(\"R\", \"S\", \"N\", \"J\", \"H\"),\n  stack3 = c(\"C\", \"R\", \"N\", \"J\", \"G\", \"Z\", \"F\", \"Q\"),\n  stack4 = c(\"F\", \"V\", \"N\", \"G\", \"R\", \"T\", \"Q\"),\n  stack5 = c(\"L\", \"T\", \"Q\", \"F\"),\n  stack6 = c(\"Q\", \"C\", \"W\", \"Z\", \"B\", \"R\", \"G\", \"N\"),\n  stack7 = c(\"F\", \"C\", \"L\", \"S\", \"N\", \"H\", \"M\"),\n  stack8 = c(\"D\", \"N\", \"Q\", \"M\", \"T\", \"J\"),\n  stack9 = c(\"P\", \"G\", \"S\")\n)"
  },
  {
    "objectID": "SOLUTIONS/Day_5.html#functions",
    "href": "SOLUTIONS/Day_5.html#functions",
    "title": "Day 5",
    "section": "Functions",
    "text": "Functions\nThis looks like we need some type queue function:\n\npush_back <- function(stacks, from, to){\n  stack_name_from <- paste0(\"stack\", from)\n  stack_name_to <- paste0(\"stack\", to)\n  \n  length_from <- length(stacks[[stack_name_from]])\n  \n  crate_to_move <- stacks[[stack_name_from]][length_from]\n  new_stacks <- stacks\n  new_stacks[[stack_name_from]] <- stacks[[stack_name_from]][-length_from]\n  new_stacks[[stack_name_to]] <- c(stacks[[stack_name_to]], crate_to_move)\n  \n  return(new_stacks)\n}"
  },
  {
    "objectID": "SOLUTIONS/Day_5.html#rearranging",
    "href": "SOLUTIONS/Day_5.html#rearranging",
    "title": "Day 5",
    "section": "Rearranging",
    "text": "Rearranging\nThis is best in base R‚Ä¶\n\ncur_stacks <- init_stacks\n\nfor(i in nrow(instructions)){\n  cur_instruction <- instructions[i,]\n\n  for(j in 1:(cur_instruction$move_how_many)){\n    cur_stacks <<- push_back(cur_stacks, cur_instruction$from, cur_instruction$to)\n  }\n}\ncur_stacks\n\n$stack1\n[1] \"F\" \"D\" \"B\" \"Z\" \"T\" \"J\" \"R\" \"N\"\n\n$stack2\n[1] \"R\" \"S\" \"N\" \"J\" \"H\"\n\n$stack3\n[1] \"C\" \"R\" \"N\" \"J\" \"G\" \"Z\" \"F\" \"Q\"\n\n$stack4\n[1] \"F\" \"V\" \"N\" \"G\" \"R\" \"T\" \"Q\"\n\n$stack5\n[1] \"L\" \"T\" \"Q\" \"F\"\n\n$stack6\n[1] \"Q\" \"C\" \"W\" \"Z\" \"B\"\n\n$stack7\n[1] \"F\" \"C\" \"L\" \"S\" \"N\" \"H\" \"M\"\n\n$stack8\n[1] \"D\" \"N\" \"Q\" \"M\" \"T\" \"J\"\n\n$stack9\n[1] \"P\" \"G\" \"S\" \"N\" \"G\" \"R\""
  },
  {
    "objectID": "SOLUTIONS/Day_5.html#whats-on-top",
    "href": "SOLUTIONS/Day_5.html#whats-on-top",
    "title": "Day 5",
    "section": "What‚Äôs on top?",
    "text": "What‚Äôs on top?\n\ntop_crates <- map_chr(\n  cur_stacks,\n  function(stack){\n    l_stack <- length(stack)\n    return(stack[l_stack])\n  }\n)\n\n\n\nThe last crates on all stacks: NHQQFBMJR! Wrong? ü§î"
  },
  {
    "objectID": "SOLUTIONS/Day_6.html",
    "href": "SOLUTIONS/Day_6.html",
    "title": "Day 6",
    "section": "",
    "text": "This is the stream of characters that needs to be proceed in sequential manner to find the start-of-packet marker. This is indicated by a sequence where all four characters are different.\n\n(\n  stream_input <- scan(\n    here(\"DATA\", \"input_day_06.txt\"),\n    what = \"character\"\n    ) %>%\n    strsplit(split = \"\", fixed = TRUE) %>%\n    unlist()\n) %>% head(10)\n\n [1] \"c\" \"v\" \"t\" \"v\" \"b\" \"v\" \"f\" \"b\" \"v\" \"f\""
  },
  {
    "objectID": "SOLUTIONS/Day_6.html#functions",
    "href": "SOLUTIONS/Day_6.html#functions",
    "title": "Day 6",
    "section": "Functions",
    "text": "Functions\nI will need to check at each item:\n\nwhether there are enough characters to create a marker (i.e., min.4) and\nwhether all last 4 are different\n\n\npop_first <- function(cur_read){\n  return(cur_read[-1])\n}\n\npush_last <- function(cur_read, new_char){\n  return(c(cur_read, new_char))\n}\n\nupdate_cur_read <- function(cur_read, new_char){\n  new_read <- pop_first(cur_read)\n  new_read <- push_last(new_read, new_char)\n  return(new_read)\n}\n\ncheck_uniqueness <- function(cur_read){\n  n_unique <- length(unique(cur_read))\n  return(n_unique == length(cur_read))\n}"
  },
  {
    "objectID": "SOLUTIONS/Day_6.html#process-input",
    "href": "SOLUTIONS/Day_6.html#process-input",
    "title": "Day 6",
    "section": "Process input",
    "text": "Process input\n\ncur_position <- 4\ncur_read <- stream_input[1:cur_position]\n\n\nwhile (!check_uniqueness(cur_read) | cur_position == length(stream_input)) {\n  cur_position <- cur_position + 1\n  new_char <- stream_input[cur_position]\n  \n  cur_read <<- update_cur_read(cur_read, new_char)\n}\n\n\n\nThe number of characters to be processed before the first start-of-packet marker is detected is 1093! ü•≥"
  },
  {
    "objectID": "SOLUTIONS/Day_6.html#detect-start-of-the-message-marker",
    "href": "SOLUTIONS/Day_6.html#detect-start-of-the-message-marker",
    "title": "Day 6",
    "section": "Detect start-of-the-message marker",
    "text": "Detect start-of-the-message marker\nThe start-of-the-message marker consists of 14 distinct characters!\n\ncur_position <- 14\ncur_read <- stream_input[1:cur_position]\n\n\nwhile (!check_uniqueness(cur_read) | cur_position == length(stream_input)) {\n  cur_position <- cur_position + 1\n  new_char <- stream_input[cur_position]\n  \n  cur_read <<- update_cur_read(cur_read, new_char)\n}\n\n\n\nThe number of characters to be processed before the first start-of-message marker is detected is 3534! ü•≥"
  },
  {
    "objectID": "SOLUTIONS/Day_3.html",
    "href": "SOLUTIONS/Day_3.html",
    "title": "Day 3",
    "section": "",
    "text": "Each line is a list of items in one rucksack.\n\n(rucksack_data <- read_table(\n  here(\"DATA\", \"input_day_03.txt\"),\n  col_names = FALSE\n))\n\n\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncols(\n  X1 = col_character()\n)\n\n\n# A tibble: 300 √ó 1\n   X1                                            \n   <chr>                                         \n 1 DMwrszrfMzSSCpLpfCCn                          \n 2 RMvhZhQqlvhMvRtbvbcPclPlncddppLTdppd          \n 3 tVMQhFtjjWmsFJsmsW                            \n 4 trRtvNhfJhSzzSTFVhQQZQhHGphP                  \n 5 CnLMBWLwDMgMcwwdngdHGPVTQGpTHZdGPGpd          \n 6 LLDqcDgwqCMnLWqtvzrzbbtJqPjJ                  \n 7 wQQwHNQLmbWQbQRHwHNFBbwqPfjqlzRMGRqzpSfvPlzplM\n 8 nCtGCZZtsGsrtDMZpfMpSlMlvlZq                  \n 9 cJctJCgVJsCJnDTsCthGhGLwBWBbbQmLbgQLQQdWbbbQ  \n10 ZWnNlTNTnhhQQlDNdmmpwrrrqBwjwjZd              \n# ‚Ä¶ with 290 more rows"
  },
  {
    "objectID": "SOLUTIONS/Day_3.html#find-the-repeating-item",
    "href": "SOLUTIONS/Day_3.html#find-the-repeating-item",
    "title": "Day 3",
    "section": "Find the repeating item",
    "text": "Find the repeating item\nFirst, we need to find the middle of each string and divide.\n\nrucksack_divided <- map(\n  rucksack_data$X1,\n  function(item_list){\n    split_at <- str_length(item_list)/2\n    out_strings <- c(\n      str_sub(item_list, start = 1, end = split_at),\n      str_sub(item_list, start = split_at + 1, end = -1)\n    )\n    return(out_strings)\n  }\n)\nrucksack_divided[[1]]\n\n[1] \"DMwrszrfMz\" \"SSCpLpfCCn\"\n\n\nNext, compare the strings in each compartment to find the repeating item for each rucksack.\n\nrepeating_items <- map(\n  rucksack_divided,\n  function(compartments){\n    unique_contents <- map(\n      compartments,\n      function(item_list){\n        strsplit(item_list, split = \"\") %>%\n          unlist() %>%\n          unique()\n      }\n    )\n    return(Reduce(f = intersect, x = unique_contents))\n  }\n)\nrepeating_items[[1]]\n\n[1] \"f\"\n\n\nChecking - do I get only one item per rucksack?\n\nlengths(repeating_items) %>%\n  unique()\n\n[1] 1\n\n\n‚úîÔ∏è Yes, great!"
  },
  {
    "objectID": "SOLUTIONS/Day_3.html#priority-of-items",
    "href": "SOLUTIONS/Day_3.html#priority-of-items",
    "title": "Day 3",
    "section": "Priority of items",
    "text": "Priority of items\nLowercase letters have priorities from 1 through 26, uppercase letters - from 27 through 52.\n\npriority_low <- str_locate(\n  paste0(letters, collapse = \"\"), letters\n)[, \"start\"]\npriority_low <- tibble(\n  letter = letters,\n  prior = priority_low\n)\npriority_low\n\n# A tibble: 26 √ó 2\n   letter prior\n   <chr>  <int>\n 1 a          1\n 2 b          2\n 3 c          3\n 4 d          4\n 5 e          5\n 6 f          6\n 7 g          7\n 8 h          8\n 9 i          9\n10 j         10\n# ‚Ä¶ with 16 more rows\n\npriority_up <- str_locate(\n  paste0(LETTERS, collapse = \"\"), LETTERS\n)[, \"start\"] + 26\npriority_up <- tibble(\n  letter = LETTERS,\n  prior = priority_up\n)\npriority_up\n\n# A tibble: 26 √ó 2\n   letter prior\n   <chr>  <dbl>\n 1 A         27\n 2 B         28\n 3 C         29\n 4 D         30\n 5 E         31\n 6 F         32\n 7 G         33\n 8 H         34\n 9 I         35\n10 J         36\n# ‚Ä¶ with 16 more rows\n\npriority_all <- bind_rows(\n  priority_low, priority_up\n)\n\nNow, find the sum of the priorities of repeated items.\n\ntotal_priority <- tibble(\n  repeat_item = unlist(repeating_items)\n  ) %>%\n  left_join(\n    priority_all,\n    by = c(\"repeat_item\" = \"letter\")\n  ) %>%\n  summarise(sum_priority = sum(prior))\n\n\n\nThe total priority is 7811! ü•≥"
  },
  {
    "objectID": "SOLUTIONS/Day_3.html#group-badges",
    "href": "SOLUTIONS/Day_3.html#group-badges",
    "title": "Day 3",
    "section": "Group badges",
    "text": "Group badges\nEach three elves create a group and they are recognized by the item that they carry. This item is the only item that is shared by these elves.\n\n# there are 3 members in each group\nno_members <- 3\n(rucksack_groups <- rucksack_data %>%\n  add_column(group_no = \n               rep(\n                 seq(1:(nrow(rucksack_data)/no_members)),\n                 each = no_members\n                )\n             ))\n\n# A tibble: 300 √ó 2\n   X1                                             group_no\n   <chr>                                             <int>\n 1 DMwrszrfMzSSCpLpfCCn                                  1\n 2 RMvhZhQqlvhMvRtbvbcPclPlncddppLTdppd                  1\n 3 tVMQhFtjjWmsFJsmsW                                    1\n 4 trRtvNhfJhSzzSTFVhQQZQhHGphP                          2\n 5 CnLMBWLwDMgMcwwdngdHGPVTQGpTHZdGPGpd                  2\n 6 LLDqcDgwqCMnLWqtvzrzbbtJqPjJ                          2\n 7 wQQwHNQLmbWQbQRHwHNFBbwqPfjqlzRMGRqzpSfvPlzplM        3\n 8 nCtGCZZtsGsrtDMZpfMpSlMlvlZq                          3\n 9 cJctJCgVJsCJnDTsCthGhGLwBWBbbQmLbgQLQQdWbbbQ          3\n10 ZWnNlTNTnhhQQlDNdmmpwrrrqBwjwjZd                      4\n# ‚Ä¶ with 290 more rows\n\nfind_common_item <- function(items_list){\n  unique_items <- map(items_list, function(items){\n    str_split(items, pattern = \"\") %>%\n      unlist() %>%\n      unique()\n  })\n  return(\n    Reduce(intersect, unique_items)\n  )\n}\n\n(rucksack_groups <- rucksack_groups %>%\n  group_by(group_no) %>%\n  summarise(\n    common_item = find_common_item(X1)\n  ) %>%\n  left_join(priority_all, by = c(\"common_item\" = \"letter\")))\n\n# A tibble: 100 √ó 3\n   group_no common_item prior\n      <int> <chr>       <dbl>\n 1        1 M              39\n 2        2 P              42\n 3        3 G              33\n 4        4 l              12\n 5        5 s              19\n 6        6 t              20\n 7        7 Z              52\n 8        8 n              14\n 9        9 p              16\n10       10 z              26\n# ‚Ä¶ with 90 more rows\n\nsum_prior <- rucksack_groups %>%\n  summarise(sum_prior = sum(prior)) %>%\n  pull()\n\n\n\nThe total priority is 2639! ü•≥"
  },
  {
    "objectID": "SOLUTIONS/Day_2.html",
    "href": "SOLUTIONS/Day_2.html",
    "title": "Day 2",
    "section": "",
    "text": "We have a special coding here - let‚Äôs write a dictionary for that:\n\nopponents codes:\n\nA = \"rock\", B = \"paper\", C = \"scissors\"\n\nmy codes:\n\nX = \"rock\", Y = \"paper\", Z = \"scissors\"\n..but the important thing is that each of these give various points, which we can basically treat as factor-levels:\n\n(games_in <- read_delim(\n  here(\"DATA\", \"input_day_02.txt\"),\n  delim = \" \",\n  col_names = FALSE,\n  skip_empty_rows = FALSE,\n  show_col_types = FALSE\n))\n\n# A tibble: 2,500 √ó 2\n   X1    X2   \n   <chr> <chr>\n 1 C     Y    \n 2 A     Z    \n 3 B     Y    \n 4 A     Z    \n 5 A     X    \n 6 A     Z    \n 7 B     Y    \n 8 A     Z    \n 9 B     Y    \n10 C     Z    \n# ‚Ä¶ with 2,490 more rows\n\ngames_fct <- games_in %>%\n  rename(opponent = X1, me = X2) %>%\n  mutate(across(.fns = as.factor))\n\n\n\n\nskimr::skim(games_fct)\n\n\nData summary\n\n\nName\ngames_fct\n\n\nNumber of rows\n2500\n\n\nNumber of columns\n2\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n2\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nopponent\n0\n1\nFALSE\n3\nB: 991, C: 795, A: 714\n\n\nme\n0\n1\nFALSE\n3\nY: 1178, Z: 771, X: 551\n\n\n\n\nlevels(games_fct$opponent)\n\n[1] \"A\" \"B\" \"C\"\n\nlevels(games_fct$me)\n\n[1] \"X\" \"Y\" \"Z\"\n\n\n‚úîÔ∏è OK, no missingness and no strange values."
  },
  {
    "objectID": "SOLUTIONS/Day_2.html#check-who-wins-per-round",
    "href": "SOLUTIONS/Day_2.html#check-who-wins-per-round",
    "title": "Day 2",
    "section": "Check who wins per round",
    "text": "Check who wins per round\nI get 0 if I lose, 3 if it‚Äôs a draw, and 6 if I win.\n\n#' returns points for player1\ncheck_rules <- function(player1, player2){\n  player1_lose <- 0\n  player1_draw <- 3\n  player1_win <- 6\n\n  all_diff <- player1 - player2\n  map_dbl(all_diff, function(cur_diff){\n    if(cur_diff == 0){ # draw\n      return(player1_draw)\n    }\n    \n    if(abs(cur_diff) == 2){ # one of them has 'rock', one 'scissors'\n      if(cur_diff < 0){\n        return(player1_win)\n      }\n      \n      return(player1_lose)\n    }\n    \n    if(cur_diff > 0){ # check who has higher value\n      return(player1_win)\n    }\n    \n    return(player1_lose)\n  })\n}\n\n(games_fct <- games_fct %>%\n  mutate(points = check_rules(as.numeric(me), as.numeric(opponent))))\n\n# A tibble: 2,500 √ó 3\n   opponent me    points\n   <fct>    <fct>  <dbl>\n 1 C        Y          0\n 2 A        Z          0\n 3 B        Y          3\n 4 A        Z          0\n 5 A        X          3\n 6 A        Z          0\n 7 B        Y          3\n 8 A        Z          0\n 9 B        Y          3\n10 C        Z          3\n# ‚Ä¶ with 2,490 more rows"
  },
  {
    "objectID": "SOLUTIONS/Day_2.html#get-total-points",
    "href": "SOLUTIONS/Day_2.html#get-total-points",
    "title": "Day 2",
    "section": "Get total points",
    "text": "Get total points\nIn addition to points gained by drawing or winning a round, I get points for what I chose (levels of factor).\n\ntotal_score <- games_fct %>%\n  mutate(total_per_round = as.numeric(me) + points) %>%\n  summarise(grand_total = sum(total_per_round))\n\n\n\nThe total score is 10941!"
  },
  {
    "objectID": "SOLUTIONS/Day_4.html",
    "href": "SOLUTIONS/Day_4.html",
    "title": "Day 4",
    "section": "",
    "text": "Each line contains a pair of sections which two elves should clean.\n\n(sections_list <- read_table(\n  here(\"DATA\", \"input_day_04.txt\"),\n  col_names = \"section_pairs\"\n))\n\n\n‚îÄ‚îÄ Column specification ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\ncols(\n  section_pairs = col_character()\n)\n\n\n# A tibble: 1,000 √ó 1\n   section_pairs\n   <chr>        \n 1 22-65,22-66  \n 2 91-94,63-91  \n 3 6-88,5-31    \n 4 85-86,64-86  \n 5 40-65,40-65  \n 6 25-82,24-94  \n 7 68-69,68-92  \n 8 60-91,89-92  \n 9 3-72,3-73    \n10 44-85,84-85  \n# ‚Ä¶ with 990 more rows\n\n\nCleaning the data a bit.\n\n(\n  sections_list <- sections_list %>%\n   #extract sections for elves\n   separate(col = section_pairs, into = c(\"elf1\", \"elf2\"), sep = \",\") %>%\n   # extract minimums and maximums for each elf\n   separate(col = elf1, into = c(\"elf1_min\", \"elf1_max\"), sep = \"-\") %>%\n   separate(col = elf2, into = c(\"elf2_min\", \"elf2_max\"), sep = \"-\") %>%\n   mutate(across(.cols = everything(), .fns = as.numeric))\n)\n\n# A tibble: 1,000 √ó 4\n   elf1_min elf1_max elf2_min elf2_max\n      <dbl>    <dbl>    <dbl>    <dbl>\n 1       22       65       22       66\n 2       91       94       63       91\n 3        6       88        5       31\n 4       85       86       64       86\n 5       40       65       40       65\n 6       25       82       24       94\n 7       68       69       68       92\n 8       60       91       89       92\n 9        3       72        3       73\n10       44       85       84       85\n# ‚Ä¶ with 990 more rows"
  },
  {
    "objectID": "SOLUTIONS/Day_4.html#overlapping",
    "href": "SOLUTIONS/Day_4.html#overlapping",
    "title": "Day 4",
    "section": "Overlapping",
    "text": "Overlapping\n\nFind entirely overlapping sections.\n\nfind_overlap <- function(min1, min2, max1, max2){\n  # check whether the second set of numbers is contained in the first\n  return(\n    (min2 >= min1) & (max2 <= max1)\n  )\n}\n\n(sections_list_entire_overlap <- sections_list %>%\n  rowwise() %>%\n  mutate(elf2_overlap = find_overlap(elf1_min, elf2_min, elf1_max, elf2_max)) %>%\n  mutate(elf1_overlap = find_overlap(elf2_min, elf1_min, elf2_max, elf1_max)))\n\n# A tibble: 1,000 √ó 6\n# Rowwise: \n   elf1_min elf1_max elf2_min elf2_max elf2_overlap elf1_overlap\n      <dbl>    <dbl>    <dbl>    <dbl> <lgl>        <lgl>       \n 1       22       65       22       66 FALSE        TRUE        \n 2       91       94       63       91 FALSE        FALSE       \n 3        6       88        5       31 FALSE        FALSE       \n 4       85       86       64       86 FALSE        TRUE        \n 5       40       65       40       65 TRUE         TRUE        \n 6       25       82       24       94 FALSE        TRUE        \n 7       68       69       68       92 FALSE        TRUE        \n 8       60       91       89       92 FALSE        FALSE       \n 9        3       72        3       73 FALSE        TRUE        \n10       44       85       84       85 TRUE         FALSE       \n# ‚Ä¶ with 990 more rows\n\n\nFind the total.\n\ntot_overlap <- sections_list_entire_overlap %>%\n  ungroup() %>%\n  mutate(any_overlap = elf2_overlap | elf1_overlap) %>%\n  summarise(sum_overlap = sum(any_overlap)) %>%\n  pull()\n\n\n\nThe total number of entirely overlapping regions is 584! ü•≥\n\n\n\n\nFind overlapping at all\n\nfind_any_overlap <- function(min1, min2, max1, max2){\n  # check whether the second set of numbers is contained in the first\n  return(\n    ((min2 >= min1) & (min2 <= max1)) |\n    ((max2 <= max1) & (max2 >= min1))\n  )\n}\n\n(sections_list_any_overlap <- sections_list %>%\n  rowwise() %>%\n  mutate(elf2_overlap = find_any_overlap(elf1_min, elf2_min, elf1_max, elf2_max)) %>%\n  mutate(elf1_overlap = find_any_overlap(elf2_min, elf1_min, elf2_max, elf1_max)))\n\n# A tibble: 1,000 √ó 6\n# Rowwise: \n   elf1_min elf1_max elf2_min elf2_max elf2_overlap elf1_overlap\n      <dbl>    <dbl>    <dbl>    <dbl> <lgl>        <lgl>       \n 1       22       65       22       66 TRUE         TRUE        \n 2       91       94       63       91 TRUE         TRUE        \n 3        6       88        5       31 TRUE         TRUE        \n 4       85       86       64       86 TRUE         TRUE        \n 5       40       65       40       65 TRUE         TRUE        \n 6       25       82       24       94 FALSE        TRUE        \n 7       68       69       68       92 TRUE         TRUE        \n 8       60       91       89       92 TRUE         TRUE        \n 9        3       72        3       73 TRUE         TRUE        \n10       44       85       84       85 TRUE         TRUE        \n# ‚Ä¶ with 990 more rows\n\n\nFind total\n\ntot_any_overlap <- sections_list_any_overlap %>%\n  ungroup() %>%\n  mutate(any_overlap = elf2_overlap | elf1_overlap) %>%\n  summarise(sum_overlap = sum(any_overlap)) %>%\n  pull()\n\n\n\nThe total number of at tall overlapping regions is 933! ü•≥"
  },
  {
    "objectID": "SOLUTIONS/Day_1.html",
    "href": "SOLUTIONS/Day_1.html",
    "title": "Day 1",
    "section": "",
    "text": "The list of calories of all items carried by the elves.\n\ndata_in_file <- here(\"DATA\", \"input_day_01.txt\")\n\n(calories_raw <- read_table(\n  data_in_file,\n  col_names = FALSE,\n  skip_empty_rows = FALSE,\n  show_col_types = FALSE\n))\n\n# A tibble: 2,240 √ó 1\n      X1\n   <dbl>\n 1  2991\n 2 13880\n 3 13279\n 4  1514\n 5  9507\n 6    NA\n 7  6544\n 8  9672\n 9 13044\n10  4794\n# ‚Ä¶ with 2,230 more rows\n\n\nEach elf inputs the calories their carrying in column, separating their items from the previous ones by an empty line.\n\n\nWhat an idea these elves had! I wonder which programming language they used?!"
  },
  {
    "objectID": "SOLUTIONS/Day_1.html#separate-elves",
    "href": "SOLUTIONS/Day_1.html#separate-elves",
    "title": "Day 1",
    "section": "Separate elves",
    "text": "Separate elves\nEach NA means new elf.\n\ncalories_new <- calories_raw %>%\n  rename(calories = X1) %>%\n  mutate(is_na = is.na(calories)) %>%\n  mutate(which_elf = cumsum(is_na) + 1)\ncalories_new\n\n# A tibble: 2,240 √ó 3\n   calories is_na which_elf\n      <dbl> <lgl>     <dbl>\n 1     2991 FALSE         1\n 2    13880 FALSE         1\n 3    13279 FALSE         1\n 4     1514 FALSE         1\n 5     9507 FALSE         1\n 6       NA TRUE          2\n 7     6544 FALSE         2\n 8     9672 FALSE         2\n 9    13044 FALSE         2\n10     4794 FALSE         2\n# ‚Ä¶ with 2,230 more rows"
  },
  {
    "objectID": "SOLUTIONS/Day_1.html#count-calories",
    "href": "SOLUTIONS/Day_1.html#count-calories",
    "title": "Day 1",
    "section": "Count calories",
    "text": "Count calories\n\ncalories_new %>%\n  group_by(which_elf) %>%\n  summarise(sum_cal = sum(calories, na.rm = TRUE)) %>%\n  arrange(desc(sum_cal))\n\n# A tibble: 245 √ó 2\n   which_elf sum_cal\n       <dbl>   <dbl>\n 1       213   68467\n 2       234   68143\n 3        89   66810\n 4        34   66631\n 5       209   65461\n 6       199   64966\n 7       145   64176\n 8       140   63815\n 9       110   63338\n10       150   63104\n# ‚Ä¶ with 235 more rows\n\n\nü•≥ TADA!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "1\n\n\n\n\n2\n\n\n\n\n3\n\n\n\n\n4\n\n\n\n\n5\n\n\n\n\n6\n\n\n\n\n7\n\n\n\n\n8\n\n\n\n\n9\n\n\n\n\n10\n\n\n\n\n11\n\n\n\n\n12\n\n\n\n\n13\n\n\n\n\n14\n\n\n\n\n15\n\n\n\n\n16\n\n\n\n\n17\n\n\n\n\n18\n\n\n\n\n19\n\n\n\n\n20\n\n\n\n\n21\n\n\n\n\n22\n\n\n\n\n23\n\n\n\n\n24"
  }
]